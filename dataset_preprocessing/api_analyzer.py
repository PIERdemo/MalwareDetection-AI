import os
from pathlib import Path
import lief
from tqdm import tqdm


def get_corrupted_files(directory_path):
    """
    This function takes in a directory path and returns the corrupted files in a list.

    :param directory_path: string, the path of the directory where the files are located
    """
    files_to_delete = []
    files_path = [str(x) for x in Path(directory_path).rglob('*') if x.is_file()]
    for file in tqdm(files_path):
        if to_delete(file):
            files_to_delete.append(file)
    return files_to_delete


def to_delete(file_path):
    """
    Thanks to the lief library, it is extracted, given the file path, all the APIs that are used by it.

    :param file_path: a string with the absolute path to the file to be parsed
    :return: a dictionary where there are two items, in the first a string representing the target class to which the
    'target_class' file belongs , the second a string with all API functions, divided by a space 'API_calls'
    """
    exe_functions = list()
    exe = lief.parse(file_path)

    if exe is None or isinstance(exe, lief.ELF.Binary):
        return True

    for imported_library in exe.imports:
        exe_functions.extend([func.name for func in imported_library.entries])

    return len(exe_functions) < 2


def remove_files(directory_path, corrupted_files):
    """
    This function takes in a directory path and a list of corrupted files as parameters.
    It iterates through the corrupted_files list and removes the corresponding file in the directory_path.

    :param directory_path: string, the path of the directory where the files are located
    :param corrupted_files: list, containing the names of the files to be removed
    """
    for file in corrupted_files:
        file_path = os.path.join(directory_path, file)
        os.remove(file_path)
