import os
import random
from tqdm import tqdm
from ember.features import PEFeatureExtractor
from pathlib import Path

from methods.utils import append_to_csv


def extract_binary(file_path):
    """
    Thanks to the ember library, it is extracted, given the file path, all the binary features with PEFeatureExtractor component.

    :param file_path: a string with the absolute path to the file to be parsed
    :return: a dictionary where there are some items, in the first a string representing the target class to which the 'target_class' file belongs , the others are all the features extracted
    """
    with open(file_path, 'rb') as executable_file:
        extractor = PEFeatureExtractor(print_feature_warning=False)
        features = [float(value) for value in extractor.feature_vector(executable_file.read())]
        features_dict = {'feature' + str(i): feature for i, feature in enumerate(features)}
        features_dict['target_class'] = file_path.split(os.sep)[-2]

        return features_dict


def binary(directory_path, csv_path, max_samples=None):
    """
    Given an input folder extracts all features from binary, from all files and writes the result to a csv file

    :param directory_path: the path to the root folder in which to perform the analysis
    :param csv_path: the path to the csv file, if not present this will be created
    :param max_samples: maximum number of samples to want to analyze, they are randomly drawn from all those in the directory_path
    :return:
    """
    files_path = [str(x) for x in Path(directory_path).rglob('*') if x.is_file()]
    if max_samples is not None:
        random.shuffle(files_path)
        files_path = files_path[:max_samples]

    for file_path in tqdm(files_path):
        append_to_csv(csv_path, extract_binary(file_path))
